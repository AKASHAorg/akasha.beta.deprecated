{"version":3,"file":"start.js","sourceRoot":"","sources":["start.ts"],"names":[],"mappings":";;AAAA,oCAAoC;AACpC,iCAAgC;AAEhC,+DAA6F;AAE7F,cAA6B,EAAE,EAAE,UAAU;IACzC,MAAM,OAAO,GAAG,OAAO,CAAC,SAAS,CAAC,QAAQ,CAAC,EAAE,IAAI;QAE/C,MAAM,aAAa,GAAG,UAAU,CAAC,uBAAW,CAAC,cAAc,CAAC,CAAC;QAC7D,MAAM,YAAY,GAAG,UAAU,CAAC,uBAAW,CAAC,aAAa,CAAC,CAAC;QAC3D,IAAI,aAAa,CAAC,WAAW,EAAE,CAAC,aAAa,CAAC,OAAO,EAAE;YACrD,OAAO,CAAC,IAAI,CAAC,yBAAyB,CAAC,CAAC;YACxC,OAAO,EAAE,OAAO,EAAE,IAAI,EAAE,CAAC;SAC1B;QAED,aAAa,CAAC,WAAW,EAAE;aACxB,aAAa,CAAC,IAAI,CAAC,cAAc,CAAC,aAAa,CAAC,CAAC,CAAC;YACjD,IAAI,CAAC,WAAW,CAAC,CAAC;YAClB,UAAU,CAAC,uBAAW,CAAC,QAAQ,CAAC,CAAC,GAAG,CAAC,4BAAgB,CAAC,iBAAiB,CAAC,CAAC,CAAC;QAE9E,MAAM,aAAa,CAAC,WAAW,EAAE,CAAC,KAAK,CAAC,eAAO,CAAC,YAAY,CAAC,QAAQ,CAAC,CAAC,CAAC;YACtE,IAAI,CAAC,CAAC,CAAC,YAAY,CAAC,QAAQ,CAAC,CAAC;QAqBhC,UAAU,CAAC,uBAAW,CAAC,QAAQ,CAAC;aAC7B,GAAG,CAAC,4BAAgB,CAAC,QAAQ,EAAE,+BAA+B,CAAC,CAAC;QAEnE,OAAO,EAAE,OAAO,EAAE,IAAI,EAAE,CAAC;IAC3B,CAAC,CAAC,CAAC;IAEH,MAAM,YAAY,GAAG,EAAE,OAAO,EAAE,IAAI,EAAE,cAAc,EAAE,CAAC;IACvD,MAAM,OAAO,GAAG;QACd,OAAO,YAAY,CAAC;IACtB,CAAC,CAAC;IACF,EAAE,EAAE,CAAC,OAAO,CAAC,uBAAW,CAAC,YAAY,EAAE,OAAO,CAAC,CAAC;IAChD,OAAO,YAAY,CAAC;AACtB,CAAC;AAjDD,uBAiDC","sourcesContent":["import * as Promise from 'bluebird';\nimport { isEmpty } from 'ramda';\n\nimport { CORE_MODULE, GENERAL_SETTINGS, IPFS_MODULE } from '@akashaproject/common/constants';\n\nexport default function init(sp, getService) {\n  const execute = Promise.coroutine(function* (data) {\n\n    const ipfsConnector = getService(CORE_MODULE.IPFS_CONNECTOR);\n    const ipfsProvider = getService(CORE_MODULE.IPFS_PROVIDER);\n    if (ipfsConnector.getInstance().serviceStatus.process) {\n      console.warn('IPFS is already running');\n      return { started: true };\n    }\n\n    ipfsConnector.getInstance()\n      .setIpfsFolder(data.hasOwnProperty('storagePath') ?\n        data.storagePath :\n        getService(CORE_MODULE.SETTINGS).get(GENERAL_SETTINGS.IPFS_DEFAULT_PATH));\n\n    yield ipfsConnector.getInstance().start(isEmpty(ipfsProvider.instance) ?\n      null : ipfsProvider.instance);\n    // @TODO: migrate this at impl lvl\n    // yield initSearchDbs();\n    // let peers;\n    // if (!isEmpty(ipfsProvider.instance)) {\n    //     const nodeId = yield IpfsConnector.getInstance().api.apiClient.idAsync();\n    //     if (nodeId && (nodeId.agentVersion).includes('go-ipfs')) {\n    //         peers = IPFS_CIRCUIT_RELAYS.concat(AKASHA_BOOTSTRAP_PEERS).concat(DEFAULT_CIRCUIT_RELAYS);\n    //     } else {\n    //         peers = AKASHA_BOOTSTRAP_PEERS.concat(DEFAULT_CIRCUIT_RELAYS);\n    //     }\n    //\n    //     peers.forEach(peer => {\n    //         IpfsConnector.getInstance().api.apiClient.swarm.connect(peer, (err) => {\n    //             if (err) {\n    //                 console.error('js-ipfs swarm connect error ', err);\n    //             }\n    //         });\n    //     });\n    // }\n\n    getService(CORE_MODULE.SETTINGS)\n      .set(GENERAL_SETTINGS.BASE_URL, 'https://gateway.ipfs.io/ipfs/');\n\n    return { started: true };\n  });\n\n  const startService = { execute, name: 'startService' };\n  const service = function () {\n    return startService;\n  };\n  sp().service(IPFS_MODULE.startService, service);\n  return startService;\n}\n"]}