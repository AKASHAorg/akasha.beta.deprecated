{"version":3,"file":"Auth.js","sourceRoot":"","sources":["Auth.ts"],"names":[],"mappings":"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","sourcesContent":["import { createCipher, createDecipher, randomBytes, Decipher, Cipher } from 'crypto';\nimport { GethConnector, gethHelper } from '@akashaproject/geth-connector';\nimport { fromRpcSig, ecrecover, isValidAddress } from 'ethereumjs-util';\nimport { Logger } from 'winston';\n\nexport default class Auth {\n    private _encrypted: Buffer;\n    private _decipher: Decipher;\n    private _cipher: Cipher;\n    private _session: {signedToken: string, address: string, expiration: Date, vrs: {v: string, r: string, s: string}};\n    private _token: string;\n\n    constructor() {\n        this._generateRandom();\n    }\n\n    /**\n     *\n     * @param pass\n     * @returns {Bluebird<string>|PromiseLike<string>|Thenable<string>|Promise<string>}\n     */\n    generateKey(pass: any) {\n        this._encrypt(pass);\n        let transformed = GethConnector.getInstance()\n            .web3\n            .fromUtf8(this._read().toString('utf8'));\n        return GethConnector.getInstance()\n            .web3\n            .personal\n            .newAccountAsync(transformed)\n            .then((address: string) => {\n                transformed = null;\n                return address;\n            });\n    }\n\n    /**\n     *\n     * @private\n     */\n    private _generateRandom() {\n        randomBytes(256, (err, buff) => {\n            if (err) {\n                throw err;\n            }\n            this._cipher = createCipher('aes-256-cbc', buff.toString('hex'));\n            this._decipher = createDecipher('aes-256-cbc', buff.toString('hex'));\n        });\n    }\n\n    /**\n     *\n     * @param key\n     * @returns {Auth}\n     * @private\n     */\n    private _encrypt(key: any) {\n        const keyTr = Buffer.from(key);\n        this._encrypted = Buffer.concat([this._cipher.update(keyTr), this._cipher.final()]);\n        return this;\n    }\n\n    /**\n     *\n     * @returns {Buffer}\n     * @private\n     */\n    private _read() {\n        return Buffer.concat([this._decipher.update(this._encrypted), this._decipher.final()]);\n    }\n\n    /**\n     *\n     * @param acc\n     * @param pass\n     * @param timer                                  number of minutes\n     * @returns {Bluebird<U>}\n     */\n    protected login(acc: string, pass: Uint8Array[], timer?: number) {\n        if (!isValidAddress(acc)) {\n            throw new Error(`${acc} is an invalid address`);\n        }\n        return gethHelper\n            .hasKey(acc)\n            .then((found) => {\n                if (!found) {\n                    throw new Error(`local key for ${acc} not found`);\n                }\n                this._encrypt(pass);\n                // temporary until personal_sign is shipped\n                // follow here https://github.com/ethereum/go-ethereum/pull/2940\n                // @TODO: migrate to personal_sign when available\n                GethConnector.getInstance()\n                    .web3\n                    .personal\n                    .unlockAccountAsync(acc, this._read().toString('utf8'), 500)\n                    .then((unlocked: boolean) => {\n                        if (!unlocked) {\n                            throw new Error(`invalid password`);\n                        }\n                        randomBytes(256, (err, buff) => {\n                            if (err) {\n                                throw err;\n                            }\n                            this._token = buff.toString('hex');\n                            this._signSession(this._token)\n                                .then((signedString: string) => {\n                                    const expiration = new Date();\n                                    expiration.setMinutes(expiration.getMinutes() + timer);\n                                    this._session = {\n                                        signedToken: signedString,\n                                        expiration,\n                                        address: acc,\n                                        vrs: fromRpcSig(signedString)\n                                    };\n                                    setTimeout(() => this._flushSession(), 1000 * 60 * timer);\n                                });\n                        });\n                    })\n                    .catch((err: any) => Logger)\n                    .finally(() => GethConnector.getInstance().web3.personal.lockAccountAsync(acc));\n            });\n    }\n\n    /**\n     *\n     * @returns {boolean}\n     */\n    public isLogged() {\n        const now = new Date();\n        if (!this._session) {\n            return false;\n        }\n\n        if (now > this._session.expiration) {\n            return false;\n        }\n        const {v, r, s} = this._session.vrs;\n        return ecrecover(this._token, v, r, s) === this._session.address;\n    }\n\n    /**\n     *\n     * @private\n     */\n    private _flushSession() {\n        this._session = null;\n        this._token = null;\n        this._encrypted = null;\n    }\n\n    // temporary\n    private _signSession(hash: string) {\n        return GethConnector.getInstance()\n            .web3\n            .eth\n            .signAsync(hash);\n    }\n\n    /**\n     *\n     * @param data\n     * @returns {Promise}\n     */\n    public signData(data: {}) {\n        if (this.isLogged()) {\n            return GethConnector.getInstance()\n                .web3\n                .personal\n                .unlockAccountAndSendTransactionAsync(data, this._read().toString('utf8'));\n        }\n        return Promise.reject(new Error('Authentication required'));\n    }\n}\n"]}