{"version":3,"file":"Auth.js","sourceRoot":"","sources":["Auth.ts"],"names":[],"mappings":";AAAA,yBAAwD,QAAQ,CAAC,CAAA;AACjE,iCAA8B,+BAA+B,CAAC,CAAA;AAG9D,kCAAsD,iBAAiB,CAAC,CAAA;AAExE;IAMI;QACI,IAAI,CAAC,eAAe,EAAE,CAAC;IAC3B,CAAC;IAED,WAAW,CAAC,IAAkB;QAC1B,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;QACpB,IAAI,WAAW,GAAG,8BAAa,CAAC,WAAW,EAAE;aACxC,IAAI;aACJ,QAAQ,CAAC,IAAI,CAAC,KAAK,EAAE,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC,CAAC;QAC7C,MAAM,CAAC,8BAAa,CAAC,WAAW,EAAE;aAC7B,IAAI;aACJ,QAAQ;aACR,eAAe,CAAC,WAAW,CAAC;aAC5B,IAAI,CAAC,CAAC,OAAe;YAClB,WAAW,GAAG,IAAI,CAAC;YACnB,MAAM,CAAC,OAAO,CAAC;QACnB,CAAC,CAAC,CAAC;IACX,CAAC;IAEO,eAAe;QACnB,oBAAW,CAAC,GAAG,EAAE,CAAC,GAAG,EAAE,IAAI;YACvB,EAAE,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;gBACN,MAAM,GAAG,CAAC;YACd,CAAC;YACD,IAAI,CAAC,OAAO,GAAG,qBAAY,CAAC,aAAa,EAAE,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC;YACjE,IAAI,CAAC,SAAS,GAAG,uBAAc,CAAC,aAAa,EAAE,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC;QACzE,CAAC,CAAC,CAAC;IACP,CAAC;IAEO,QAAQ,CAAC,GAAiB;QAC9B,MAAM,KAAK,GAAG,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;QAC/B,IAAI,CAAC,UAAU,GAAG,MAAM,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,EAAE,IAAI,CAAC,OAAO,CAAC,KAAK,EAAE,CAAC,CAAC,CAAC;QACpF,MAAM,CAAC,IAAI,CAAC;IAChB,CAAC;IAEO,KAAK;QACT,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,IAAI,CAAC,UAAU,CAAC,EAAG,IAAI,CAAC,SAAS,CAAC,KAAK,EAAE,CAAC,CAAC,CAAC;IAC5F,CAAC;IAES,KAAK,CAAC,GAAW,EAAE,IAAkB,EAAE,KAAc;QAC3D,EAAE,CAAC,CAAC,CAAE,gCAAc,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;YACxB,MAAM,IAAI,KAAK,CAAC,GAAG,GAAG,wBAAwB,CAAC,CAAC;QACpD,CAAC;IAIL,CAAC;AACL,CAAC;AArDD;sBAqDC,CAAA","sourcesContent":["import {createCipher, createDecipher, randomBytes} from 'crypto';\nimport { GethConnector } from '@akashaproject/geth-connector';\nimport { Decipher } from 'crypto';\nimport { Cipher } from 'crypto';\nimport { fromRpcSig, ecrecover, isValidAddress } from 'ethereumjs-util';\n\nexport default class Auth {\n    private _encrypted: Buffer;\n    private _decipher: Decipher;\n    private _cipher: Cipher;\n    private _session: {token: string, expiration: Date};\n\n    constructor() {\n        this._generateRandom();\n    }\n\n    generateKey(pass: Uint8Array[]) {\n        this._encrypt(pass);\n        let transformed = GethConnector.getInstance()\n            .web3\n            .fromUtf8(this._read().toString('utf8'));\n        return GethConnector.getInstance()\n            .web3\n            .personal\n            .newAccountAsync(transformed)\n            .then((address: string) => {\n                transformed = null;\n                return address;\n            });\n    }\n\n    private _generateRandom() {\n        randomBytes(256, (err, buff) => {\n            if (err) {\n                throw err;\n            }\n            this._cipher = createCipher('aes-256-cbc', buff.toString('hex'));\n            this._decipher = createDecipher('aes-256-cbc', buff.toString('hex'));\n        });\n    }\n\n    private _encrypt(key: Uint8Array[]) {\n        const keyTr = Buffer.from(key);\n        this._encrypted = Buffer.concat([this._cipher.update(keyTr), this._cipher.final()]);\n        return this;\n    }\n\n    private _read() {\n        return Buffer.concat([this._decipher.update(this._encrypted) , this._decipher.final()]);\n    }\n\n    protected login(acc: string, pass: Uint8Array[], timer?: number) {\n        if (! isValidAddress(acc)) {\n            throw new Error(`${acc} is an invalid address`);\n        }\n        /**\n         *\n         */\n    }\n}\n"]}