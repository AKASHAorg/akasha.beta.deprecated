{"version":3,"file":"Auth.js","sourceRoot":"","sources":["Auth.ts"],"names":[],"mappings":";AAAA,yBAAwD,QAAQ,CAAC,CAAA;AACjE,iCAA8B,+BAA+B,CAAC,CAAA;AAI9D;IAKI;QACI,IAAI,CAAC,eAAe,EAAE,CAAC;IAC3B,CAAC;IAED,WAAW;QACP,IAAI,WAAW,GAAG,8BAAa,CAAC,WAAW,EAAE;aACxC,IAAI;aACJ,QAAQ,CAAC,IAAI,CAAC,KAAK,EAAE,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC,CAAC;QAC7C,MAAM,CAAC,8BAAa,CAAC,WAAW,EAAE;aAC7B,IAAI;aACJ,QAAQ;aACR,eAAe,CAAC,WAAW,CAAC;aAC5B,IAAI,CAAC,CAAC,OAAe;YAClB,WAAW,GAAG,IAAI,CAAC;YACnB,MAAM,CAAC,OAAO,CAAC;QACnB,CAAC,CAAC,CAAC;IACX,CAAC;IAEO,eAAe;QACnB,oBAAW,CAAC,GAAG,EAAE,CAAC,GAAG,EAAE,IAAI;YACvB,EAAE,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;gBACN,MAAM,GAAG,CAAC;YACd,CAAC;YACD,IAAI,CAAC,OAAO,GAAG,qBAAY,CAAC,aAAa,EAAE,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC;YACjE,IAAI,CAAC,SAAS,GAAG,uBAAc,CAAC,aAAa,EAAE,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC;QACzE,CAAC,CAAC,CAAC;IACP,CAAC;IAES,OAAO,CAAC,GAAiB;QAC/B,MAAM,KAAK,GAAG,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;QAC/B,IAAI,CAAC,UAAU,GAAG,MAAM,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,EAAE,IAAI,CAAC,OAAO,CAAC,KAAK,EAAE,CAAC,CAAC,CAAC;IACxF,CAAC;IAEO,KAAK;QACT,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,IAAI,CAAC,UAAU,CAAC,EAAG,IAAI,CAAC,SAAS,CAAC,KAAK,EAAE,CAAC,CAAC,CAAC;IAC5F,CAAC;AACL,CAAC;AAzCD;sBAyCC,CAAA","sourcesContent":["import {createCipher, createDecipher, randomBytes} from 'crypto';\nimport { GethConnector } from '@akashaproject/geth-connector';\nimport { Decipher } from 'crypto';\nimport { Cipher } from 'crypto';\n\nexport default class Auth {\n    private _encrypted: Buffer;\n    private _decipher: Decipher;\n    private _cipher: Cipher;\n\n    constructor() {\n        this._generateRandom();\n    }\n\n    generateKey() {\n        let transformed = GethConnector.getInstance()\n            .web3\n            .fromUtf8(this._read().toString('utf8'));\n        return GethConnector.getInstance()\n            .web3\n            .personal\n            .newAccountAsync(transformed)\n            .then((address: string) => {\n                transformed = null;\n                return address;\n            });\n    }\n\n    private _generateRandom() {\n        randomBytes(256, (err, buff) => {\n            if (err) {\n                throw err;\n            }\n            this._cipher = createCipher('aes-256-cbc', buff.toString('hex'));\n            this._decipher = createDecipher('aes-256-cbc', buff.toString('hex'));\n        });\n    }\n\n    protected encrypt(key: Uint8Array[]) {\n        const keyTr = Buffer.from(key);\n        this._encrypted = Buffer.concat([this._cipher.update(keyTr), this._cipher.final()]);\n    }\n\n    private _read() {\n        return Buffer.concat([this._decipher.update(this._encrypted) , this._decipher.final()]);\n    }\n}\n"]}