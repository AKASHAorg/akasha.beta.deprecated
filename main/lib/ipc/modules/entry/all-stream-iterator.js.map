{"version":3,"file":"all-stream-iterator.js","sourceRoot":"","sources":["all-stream-iterator.ts"],"names":[],"mappings":"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","sourcesContent":["import * as Promise from 'bluebird';\nimport { constructed as contracts } from '../../contracts/index';\nimport { mixed } from '../models/records';\nimport { BLOCK_INTERVAL, A_STREAM_I } from '../../config/settings';\nimport { GethConnector } from '@akashaproject/geth-connector';\nimport getEntry from './get-entry';\n\n\nconst fetch = Promise.coroutine(function*(entries, toBlock, limit) {\n    const fromBlock = toBlock - BLOCK_INTERVAL;\n    const filter = { fromBlock: (fromBlock > 0) ? fromBlock : 0, toBlock: toBlock };\n    let rounds = limit;\n    let events, lastBlock;\n    while (rounds--) {\n        events = yield contracts.instance.entries.getPublished(filter);\n        yield Promise.delay(25);\n    }\n\n    events.sort((a, b) => {\n        return b.blockNumber - a.blockNumber;\n    });\n\n    for (let i = 0; i < events.length; i++) {\n        entries.add(events[i].args.entryId.toString());\n        if (entries.size === limit) {\n            lastBlock = events[i].blockNumber;\n            break;\n        }\n    }\n    return lastBlock;\n});\n\nconst execute = Promise.coroutine(function*(data: { limit?: number, toBlock?: number }) {\n    let toBlock = (data.toBlock) ? data.toBlock :\n        yield GethConnector.getInstance()\n            .web3\n            .eth\n            .getBlockNumberAsync();\n    const indexBlock = toBlock;\n\n    const limit = (data.limit) ? data.limit : 5;\n    let lastBlock, entries, cache;\n    if (mixed.hasFull(`${A_STREAM_I}${data.toBlock}`)) {\n        cache = mixed.getFull(`${A_STREAM_I}${data.toBlock}`);\n        entries = cache.entries;\n        lastBlock = cache.lastBlock;\n    } else {\n        entries = new Set();\n        while (entries.size < limit && toBlock > 0) {\n            lastBlock = yield fetch(entries, toBlock, limit);\n            toBlock -= BLOCK_INTERVAL;\n        }\n        mixed.setFull(`${A_STREAM_I}${indexBlock}`, { entries, lastBlock });\n    }\n\n    const collection = yield Promise.all(Array.from(entries).map((entryId) => getEntry.execute({ entryId })));\n    return { collection, toBlock: data.toBlock, lastBlock: lastBlock, limit };\n});\n\nexport default { execute, name: 'allStreamIterator' };\n"]}